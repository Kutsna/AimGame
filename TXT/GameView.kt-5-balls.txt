package com.example.aimgame

import android.app.Activity
import android.app.AlertDialog
import android.content.Context
import android.content.SharedPreferences
import android.graphics.*
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.media.AudioAttributes
import android.media.SoundPool
import android.os.Handler
import android.os.Looper
import android.text.Html
import android.util.Log
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import kotlin.math.atan2
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.sin
import kotlin.math.cos
import kotlin.math.sqrt
import kotlin.random.Random
import kotlin.system.exitProcess


class GameView(context: Context) : View(context), SensorEventListener {

    interface LevelStartListener {
        fun onLevelStarted(currentLevel: Int)
    }
    var levelStartListener: LevelStartListener? = null

    // Sensor and physics.
    private val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager
    private val accelerometer: Sensor? = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
    private var accelX = 0f
    private var accelY = 0f
    private val friction = 0.99f

    // --- Reordered Balls Array:
    // Balls are arranged so that index 4 (the central ball) is the largest.
    private val balls = arrayOf(
        // Index 4: largest central ball (red ring)
        Ball(0f, 0f, 0f, 0f, 38f * 1.6f, basePoints = 100),
        // Index 3: next (yellow ring)
        Ball(0f, 0f, 0f, 0f, 30f * 1.45f, basePoints = 200),
        // Index 2: next (green ring)
        Ball(0f, 0f, 0f, 0f, 24f * 1.35f, basePoints = 300),
        // Index 1: next (gold ring)
        Ball(0f, 0f, 0f, 0f, 20f * 1.25f, basePoints = 400),
        // Index 0: smallest (associated with violet ring)
        Ball(0f, 0f, 0f, 0f, 16f * 1.15f, basePoints = 500)
    )

    // Data class for a ball.
    data class Ball(
        var x: Float,
        var y: Float,
        var vx: Float,
        var vy: Float,
        val radius: Float,
        var placed: Boolean = false,
        var active: Boolean = false,
        var canSnap: Boolean = true,
        val basePoints: Int,          // each ball carries its own point value

        var orbiting: Boolean = false,
        var orbitCenterX: Float = 0f,
        var orbitCenterY: Float = 0f,
        var orbitRadius: Float = 0f,
        var orbitAngle: Float = 0f,
        var orbitAccum: Float = 0f             // total radians travelled so far
    )

    // data class for one little floating +100 animation
    private data class FloatingScore(
        var x: Float,
        var y: Float,
        val text: String,
        var alpha: Int = 255,
        var size: Float,
        val dx: Float,        // horizontal motion per frame
        val dy: Float,        // vertical motion per frame
        val color: Int
    )

    // Hole positions used for snapping.
    // Initially these are provided as relative fractions but updated positions from MainActivity are absolute.
    private var holePositions: Array<Pair<Float, Float>> = arrayOf(
        Pair(0.5f, 0.483f),     // red ring hole (central)
        Pair(0.573f, 0.52f),   // yellow ring hole
        Pair(0.632f, 0.55f),   // green ring hole
        Pair(0.69f, 0.578f),   // gold ring hole
        Pair(0.75f, 0.607f)    // violet ring hole

    )
    private var holePositionsAbsolute: Boolean = false

    private val floatingColors = arrayOf(
        Color.RED,     // central (index 0)
        Color.YELLOW,  // index 1
        Color.GREEN,   // index 2
        Color.rgb(255, 150, 0), // index 3
        Color.MAGENTA     // index 4
    )

    /**
     * Updates the hole positions used for ball snapping.
     * The positions are expected to be absolute screen coordinates (in pixels).
     */
    fun updateHolePositions(newPositions: Array<Pair<Float, Float>>) {
        holePositions = newPositions
        holePositionsAbsolute = true
        Log.d("GameView", "Updated hole positions:")
        holePositions.forEachIndexed { index, pos ->
            Log.d("GameView", "Hole $index: (${pos.first}, ${pos.second})")
        }
    }

    // SoundPool and sounds.
    private val soundPool: SoundPool
    private val soundIds = mutableMapOf<String, Int>()
    private val handler = Handler(Looper.getMainLooper())

    // list to hold ongoing animations
    private val floatingScores = mutableListOf<FloatingScore>()

    // how long each floats (ms)
    private val FLOAT_DURATION = 3600L

    // Game state.
    private var currentLevel = 1
    private var levelTimeLimit = 60 // seconds
    private var levelStartTime = 0L
    private var levelTimer = 60 // seconds remaining
    private var overallScore = 0 // overall score so far
    private var levelStartScore = 0 // score at the beginning of the level
    private var ballSpawnIndex = 0 // sequential ball spawning index
    private val spawnDelay = 500L // delay between ball spawns (ms)
    private var levelFailed = false
    private var levelCompleted = false
    private var gamePaused = false
    private var timerStarted = false
    private var timerPaused = false
    private var pausedElapsed: Long = 0L
    private var scoreFrozen = false
    private var failureAlertShown = false
    private var startDialogShowing = false

    // Save-and-Exit and Pause button rectangles.
    private var saveExitButtonRect: RectF = RectF()
    private var pauseButtonRect: RectF = RectF()

    // SharedPreferences.
    private val prefs: SharedPreferences =
        context.getSharedPreferences("AimgamePrefs", Context.MODE_PRIVATE)

    private var failureDialogRunnable: Runnable? = null

    // New variables for the Options menu.
    private var optionsExpanded = false
    private var optionsButtonRect: RectF = RectF()
    // We'll compute item rectangles on the fly in onDraw.
    private val optionsList = listOf("Save&Exit", "New game", "Tilted", "Flat")

    private var baselineSet = false
    private var baselineX = 0f
    private var baselineY = 0f


    init {
        keepScreenOn = true
        sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_GAME)
        val audioAttributes = AudioAttributes.Builder()
            .setUsage(AudioAttributes.USAGE_GAME)
            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
            .build()
        soundPool = SoundPool.Builder()
            .setMaxStreams(10)
            .setAudioAttributes(audioAttributes)
            .build()
        soundIds["ball1"] = soundPool.load(context, R.raw.ball1_click, 1)
        soundIds["ball2"] = soundPool.load(context, R.raw.ball2_click, 1)
        soundIds["ball3"] = soundPool.load(context, R.raw.ball3_click, 1)
        soundIds["ball4"] = soundPool.load(context, R.raw.ball4_click, 1)
        soundIds["ball5"] = soundPool.load(context, R.raw.ball5_click, 1)
        soundIds["edge"] = soundPool.load(context, R.raw.edge_wrap_click, 1)
        soundIds["success"] = soundPool.load(context, R.raw.success_chime, 1)
        soundIds["pwa"] = soundPool.load(context, R.raw.pwa, 1)
        soundIds["fail"] = soundPool.load(context, R.raw.fail, 1)
        soundIds["ballout"] = soundPool.load(context, R.raw.ballout, 1)
        soundIds["bell"]   = soundPool.load(context, R.raw.bell, 1)
        loadGameState()
        startDialogShowing = true
        showStartDialog()
    }

    fun calibrateBaseline() {
        // Reset the flag so that the next sensor reading is used.
        baselineSet = false
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        optionsButtonRect = RectF(20f, h - 500f, 420f, h - 400f)
        saveExitButtonRect = RectF(w - 220f, 20f, w - 20f, 120f)
        pauseButtonRect = RectF(20f, 20f, 220f, 120f)
        super.onSizeChanged(w, h, oldw, oldh)
    }

    override fun onTouchEvent(event: MotionEvent): Boolean {
        if (event.action == MotionEvent.ACTION_DOWN) {
            // Don’t allow Options while any blocking dialog is up:
            if (startDialogShowing || levelFailed || levelCompleted) return super.onTouchEvent(event)

            // Check if the Options button is tapped.
            if (optionsButtonRect.contains(event.x, event.y)) {
                // Pause game and timer when Options is pressed.
                if (!gamePaused) {
                    pauseGame()
                } else
                    resumeGame()
                optionsExpanded = !optionsExpanded
                invalidate()
                return true
            }
            // When the Options menu is expanded, check if any option item was touched.
            if (optionsExpanded) {
                val itemHeight = 90f
                val spacing = 15f
                val itemsRects = mutableListOf<RectF>()
                var currentTop = optionsButtonRect.top - spacing - itemHeight
                for (label in optionsList) {
                    itemsRects.add(RectF(optionsButtonRect.left, currentTop, optionsButtonRect.right, currentTop + itemHeight))
                    currentTop -= (itemHeight + spacing)
                }
                for (i in itemsRects.indices) {
                    if (itemsRects[i].contains(event.x, event.y)) {
                        handleOptionSelection(i)
                        optionsExpanded = false
                        invalidate()
                        return true
                    }
                }
                // Touch outside: collapse the menu.
                optionsExpanded = false
                resumeGame()
            }
        }
        return super.onTouchEvent(event)
    }


    private fun handleOptionSelection(index: Int) {
        when (index) {
            0 -> {                         // "Save & Exit"
                saveGameState()
                exitProcess(0)
            }
            1 -> newGame()                 // "New game"
            2 -> {                         // "Tilted"
                orientationOffset = -45    // Rotate sensor values by -45° so the game behaves as flat.
                Log.d("Options", "Orientation set to Tilted; calibrating baseline.")
                calibrateBaseline()       // This will cause the next sensor reading to become the new baseline.
                resumeGame()
            }
            3 -> {                         // "Flat"
                orientationOffset = 0    // Set Flat mode (no rotation)
                // Reset calibration to default: effectively no offset.
                baselineSet = true
                baselineX = 0f
                baselineY = 0f
                Log.d("Options", "Orientation set to Flat; calibration reset to default (0,0).")
                resumeGame()
            }

        }
    }

    // Orientation offset; used in onSensorChanged to adjust accelerometer values.
    var orientationOffset = 0  // 0: Flat (original)


    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)

        // ─── Draw black spots on all holes ──────────────────────────────
        val holePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.BLACK
            style = Paint.Style.FILL
        }
        // radius of each spot (tweak as needed)
        val holeRadius = 20f

        for ((fx, fy) in holePositions) {
            val x = if (holePositionsAbsolute) fx else fx * width
            val y = if (holePositionsAbsolute) fy else fy * height
            canvas.drawCircle(x, y, holeRadius, holePaint)
        }


        // ---- Draw Options button text with bold and stroke ----
        if (!startDialogShowing && !levelFailed && !levelCompleted) {
        val optionsTextFillPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.WHITE
            textSize = 72f  // doubled size.
            typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
            style = Paint.Style.FILL
            textAlign = Paint.Align.CENTER
        }
        val optionsTextStrokePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.BLACK
            textSize = 72f
            typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
            style = Paint.Style.STROKE
            strokeWidth = 4f  // adjust stroke width as needed.
            textAlign = Paint.Align.CENTER
        }
        canvas.drawRoundRect(optionsButtonRect, 10f, 10f, Paint().apply {
            color = Color.DKGRAY
            isAntiAlias = true
        })
        // Draw the Options text with stroke then fill.
        canvas.drawText("Options", optionsButtonRect.centerX() - 40f, optionsButtonRect.centerY() + 20f, optionsTextStrokePaint)
        canvas.drawText("Options", optionsButtonRect.centerX() - 40f, optionsButtonRect.centerY() + 20f, optionsTextFillPaint)

        // If options menu is expanded, draw the list above the options button.
        if (optionsExpanded) {
            val itemHeight = 90f
            val spacing = 15f
            var currentTop = optionsButtonRect.top - spacing - itemHeight
            for (label in optionsList) {
                val itemRect = RectF(optionsButtonRect.left, currentTop, optionsButtonRect.right, currentTop + itemHeight)
                // Draw background for each item.
                val bgPaint = Paint().apply {
                    color = Color.GRAY
                    alpha = 200
                    isAntiAlias = true
                }
                canvas.drawRoundRect(itemRect, 20f, 20f, bgPaint)

                val itemTextFillPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
                    color = Color.WHITE
                    textSize = 32f * 2  // doubled from 32f to 64f
                    typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
                    style = Paint.Style.FILL
                    textAlign = if (label == "Flat" || label == "Tilted") Paint.Align.LEFT else Paint.Align.LEFT
                }
                val itemTextStrokePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
                    color = Color.BLACK
                    textSize = 32f * 2  // 64f
                    typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
                    style = Paint.Style.STROKE
                    strokeWidth = 3f
                    textAlign = if (label == "Flat" || label == "Tilted") Paint.Align.LEFT else Paint.Align.LEFT
                }
                // For left-aligned items, give a left margin.
                val xPos = if (label == "Flat" || label == "Tilted") itemRect.left + 10f else itemRect.left
                canvas.drawText(label, xPos, itemRect.centerY() + 20f, itemTextStrokePaint)
                canvas.drawText(label, xPos, itemRect.centerY() + 20f, itemTextFillPaint)
                currentTop -= (itemHeight + spacing)
            }
        }
        }

        // Draw UI (score, timer, level) at the bottom.
        if (!levelCompleted && !levelFailed) {
            // Define margins and bar dimensions.
            val barMargin = 20f           // doubled from 20f.
            val bottomMargin = 20f          // doubled from 20f.
            // Using the factor from your previous code: (35f * 1.8f) was your base height; multiply by 2:
            val barHeight = 35f * 2.8f  // same for each bar.
            val gapBetweenBars = 16f        // doubled from 8f.
            val barMaxWidth = width - 2 * barMargin

            // Compute vertical positions for each bar. We want to show three bars (Level, Score, Time)
            // stacked from top (highest bar) to bottom. The bottom bar (Time) sits above bottomMargin.
            val timeBarTop = height - bottomMargin - barHeight
            val scoreBarTop = timeBarTop - gapBetweenBars - barHeight
            val levelBarTop = scoreBarTop - gapBetweenBars - barHeight

            // Level Bar (red)
            val levelFraction = (currentLevel / 10f).coerceIn(0f, 1f)
            val filledLevelWidth = levelFraction * barMaxWidth
            val levelBarPaint = Paint().apply { color = Color.rgb(255, 150, 0) }
            canvas.drawRect(barMargin, levelBarTop, barMargin + filledLevelWidth, levelBarTop + barHeight, levelBarPaint)

            val levelTextFillPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
                color = Color.YELLOW
                textSize = 70f
                typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
                style = Paint.Style.FILL
                textAlign = Paint.Align.LEFT
            }
            val levelTextStrokePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
                color = Color.BLACK
                textSize = 70f
                typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
                style = Paint.Style.STROKE
                strokeWidth = 4f
                textAlign = Paint.Align.LEFT
            }
            canvas.drawText("Level: $currentLevel", barMargin + 20f, levelBarTop + barHeight - 20f, levelTextStrokePaint)
            canvas.drawText("Level: $currentLevel", barMargin + 20f, levelBarTop + barHeight - 20f, levelTextFillPaint)

            // Score Bar (blue)
            val scoreFraction = (overallScore / 10000f).coerceIn(0f, 1f)
            val filledScoreWidth = scoreFraction * barMaxWidth
            val scoreBarPaint = Paint().apply { color = Color.BLUE }
            canvas.drawRect(barMargin, scoreBarTop, barMargin + filledScoreWidth, scoreBarTop + barHeight, scoreBarPaint)
            val scoreTextFillPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
                color = Color.WHITE
                textSize = 70f
                typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
                style = Paint.Style.FILL
                textAlign = Paint.Align.LEFT
            }
            val scoreTextStrokePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
                color = Color.BLACK
                textSize = 70f
                typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
                style = Paint.Style.STROKE
                strokeWidth = 4f
                textAlign = Paint.Align.LEFT
            }
            canvas.drawText("Score: $overallScore", barMargin + 20f, scoreBarTop + barHeight - 20f, scoreTextStrokePaint)
            canvas.drawText("Score: $overallScore", barMargin + 20f, scoreBarTop + barHeight - 20f, scoreTextFillPaint)

            // Time Bar (interpolated color)
            val currentTime = System.currentTimeMillis()
            // if timerPaused, use the frozen pausedElapsed; otherwise use the live clock
            val rawElapsed = if (timerPaused) {
                pausedElapsed.toFloat() / 1000f
            } else {
                (currentTime - levelStartTime).toFloat() / 1000f
            }
            val elapsedTime = if (currentLevel == 1 && !timerStarted) 0f else rawElapsed
            val effectiveElapsed = if (elapsedTime > levelTimeLimit) levelTimeLimit.toFloat() else elapsedTime
            levelTimer = (levelTimeLimit - effectiveElapsed).toInt()

            // Compute timeFraction clamped to [0,1].
            val timeFraction = ((levelTimeLimit - effectiveElapsed) / levelTimeLimit).coerceIn(0f, 1f)

            val filledTimeWidth = timeFraction * barMaxWidth

            fun interpolateColor(start: Int, end: Int, fraction: Float): Int {
                val a = Color.alpha(start) + ((Color.alpha(end) - Color.alpha(start)) * fraction).toInt()
                val r = Color.red(start) + ((Color.red(end) - Color.red(start)) * fraction).toInt()
                val g = Color.green(start) + ((Color.green(end) - Color.green(start)) * fraction).toInt()
                val b = Color.blue(start) + ((Color.blue(end) - Color.blue(start)) * fraction).toInt()
                return Color.argb(a, r, g, b)
            }
            val green = Color.GREEN
            val yellow = Color.YELLOW
            val orange = Color.rgb(255, 165, 0)
            val red = Color.RED
            val timeBarColor: Int = when {
                timeFraction >= 0.66f -> {
                    val localFrac = (timeFraction - 0.66f) / (1f - 0.66f)
                    interpolateColor(yellow, green, localFrac)
                }
                timeFraction >= 0.33f -> {
                    val localFrac = (timeFraction - 0.33f) / (0.66f - 0.33f)
                    interpolateColor(orange, yellow, localFrac)
                }
                else -> {
                    val localFrac = timeFraction / 0.33f
                    interpolateColor(red, orange, localFrac)
                }
            }
            val timeBarPaint = Paint().apply { color = timeBarColor }
            canvas.drawRect(barMargin, timeBarTop, barMargin + filledTimeWidth, timeBarTop + barHeight, timeBarPaint)

            val timeTextFillPaint = Paint().apply {
                color = Color.RED
                textSize = 70f
                typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
                style = Paint.Style.FILL
                textAlign = Paint.Align.LEFT
            }
            val timeTextStrokePaint = Paint().apply {
                color = Color.BLACK
                textSize = 70f
                typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
                style = Paint.Style.STROKE
                strokeWidth = 4f
                textAlign = Paint.Align.LEFT
            }
            canvas.drawText("Time: $levelTimer", barMargin + 20f, timeBarTop + barHeight - 20f, timeTextStrokePaint)
            canvas.drawText("Time: $levelTimer", barMargin + 20f, timeBarTop + barHeight - 20f, timeTextFillPaint)
        }


        // Update game state if not paused.
        if (!startDialogShowing && (!gamePaused || levelFailed)) {
            updateGameState()
            }

        // draw & advance all floating scores
        val stroke = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            style = Paint.Style.STROKE; strokeWidth = 3f; color = Color.BLACK
        }
        val fill = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            style = Paint.Style.FILL
        }

        val iter = floatingScores.iterator()
        while (iter.hasNext()) {
            val fs = iter.next()

            // set current paint state
            stroke.textSize = fs.size
            stroke.alpha    = fs.alpha
            fill.textSize   = fs.size
            fill.alpha      = fs.alpha
            fill.color      = fs.color

            // draw stroke then fill
            canvas.drawText(fs.text, fs.x, fs.y, stroke)
            canvas.drawText(fs.text, fs.x, fs.y, fill)

            // advance position & fade & grow
            fs.x    += fs.dx      // horizontal drift
            fs.y    += fs.dy      // vertical drift (negative dy → upward)
            fs.alpha = (fs.alpha - 2).coerceAtLeast(0)  // fade 2 units/frame (slower)
            fs.size  *= 1.02f     // grow 2% per frame

            // remove when invisible
            if (fs.alpha == 0) iter.remove()
        }

            // Draw balls.
        for (ball in balls) {
            if (!ball.active) continue
            val shadowPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { color = Color.argb(80, 0, 0, 0) }
            val shadowOffset = ball.radius / 3
            canvas.drawCircle(ball.x + shadowOffset, ball.y + shadowOffset, ball.radius, shadowPaint)
            val ballPaint = Paint(Paint.ANTI_ALIAS_FLAG)
            ballPaint.shader = RadialGradient(
                ball.x - ball.radius / 4,
                ball.y - ball.radius / 4,
                ball.radius,
                intArrayOf(Color.WHITE, Color.DKGRAY),
                floatArrayOf(0.3f, 1f),
                Shader.TileMode.CLAMP
            )
            canvas.drawCircle(ball.x, ball.y, ball.radius, ballPaint)
        }
        postInvalidateOnAnimation()
    }

    // --- Updated Game Physics and Snapping (with collision handling improvements).
    private fun updateGameState() {
        val currentTime = System.currentTimeMillis()

        // ── 1) Compute elapsed time, honoring pause ──────────────────────────
        val rawElapsed = (currentTime - levelStartTime).toFloat() / 1000f
        // Level-1 waits until first ball snaps
        val elapsedTime = if (currentLevel == 1 && !timerStarted) 0f else rawElapsed
        // never exceed the time limit
        val effectiveElapsed = if (elapsedTime > levelTimeLimit) levelTimeLimit.toFloat() else elapsedTime
        levelTimer = (levelTimeLimit - effectiveElapsed).toInt()

        // ── 2) Recompute score once per snapped ball (they carry their own basePoints) ─────────
        val placedPoints = balls.sumOf { ball ->
            if (ball.placed) ball.basePoints * currentLevel else 0
            }

        var computedScore = levelStartScore + placedPoints
        if (computedScore < 0) {
            computedScore = 0
            scoreFrozen = true
        }
        overallScore = computedScore

        // ── 3) VORTEX ANIMATION ─────────────────────────────────────────────
        // If a ball is orbiting, spin it around its hole 3 times, shrinking each frame.
        val laps        = 3
        val totalAngle  = laps * 2 * Math.PI.toFloat()
        val angularStep = (2 * Math.PI.toFloat()) / 60f   // one lap in ~60 frames
        val decay       = 0.98f                           // shrink radius 2% per frame

        balls.forEach { ball ->
            if (ball.orbiting) {
                // advance swirl
                ball.orbitAngle += angularStep
                ball.orbitAccum += angularStep
                ball.orbitRadius *= decay

                // place on circle
                ball.x = ball.orbitCenterX + cos(ball.orbitAngle) * ball.orbitRadius
                ball.y = ball.orbitCenterY + sin(ball.orbitAngle) * ball.orbitRadius

                // finish after 3 laps
                if (ball.orbitAccum >= totalAngle) {
                    ball.orbiting = false
                    ball.placed   = true
                    // snap home exactly
                    ball.x = ball.orbitCenterX
                    ball.y = ball.orbitCenterY
                    // final pwa sound
                    playSound("pwa")
                }
                // skip normal physics for an orbiting ball
                return@forEach
            }
        }

        // ── 4) Physics on non-placed, non-orbiting balls ── Set snapping threshold factor.
        val snappingThresholdFactor = when (currentLevel) {
            1 -> 2.5f
            2 -> 2.5f
            3 -> 2.0f
            4 -> 1.5f
            else -> 1.0f
        }
        val effectiveSensitivity = when (currentLevel) {
            1 -> 0.1f
            2 -> 0.2f
            3 -> 0.5f
            4 -> 0.70f
            else -> 1.0f
        }

        // Update moving balls.
        for (ball in balls) {
            if (!ball.active || ball.placed) continue
            val smallestRadius = balls.minOf { it.radius }
            val massFactor = (smallestRadius / ball.radius) * 0.8f
            ball.vx += (-accelX * effectiveSensitivity) * massFactor
            ball.vy += (accelY * effectiveSensitivity) * massFactor
            ball.vx *= friction
            ball.vy *= friction
            ball.x += ball.vx
            ball.y += ball.vy

            if (ball.x < ball.radius) {
                ball.x = ball.radius
                ball.vx = -ball.vx
            } else if (ball.x > width - ball.radius) {
                ball.x = width - ball.radius
                ball.vx = -ball.vx
            }
            if (ball.y < ball.radius) {
                ball.y = ball.radius
                ball.vy = -ball.vy
            } else if (ball.y > height - ball.radius) {
                ball.y = height - ball.radius
                ball.vy = -ball.vy
            }
        }
        // Collision handling: Bounce balls off each other.
        for (i in balls.indices) {
            for (j in i+1 until balls.size) {
                val b1 = balls[i]; val b2 = balls[j]
                if (!b1.active || !b2.active) continue
                val dx = b2.x - b1.x; val dy = b2.y - b1.y
                val dist = hypot(dx.toDouble(), dy.toDouble()).toFloat()
                if (dist < b1.radius + b2.radius) {
                    // levels 1–4: if one is placed, bounce only the moving one
                    if (currentLevel <= 4 && (b1.placed xor b2.placed)) {
                        val imm = if(b1.placed) b1 else b2
                        val mov = if(b1.placed) b2 else b1
                        val ddx = mov.x - imm.x; val ddy = mov.y - imm.y
                        val d   = hypot(ddx.toDouble(), ddy.toDouble()).toFloat()
                        if (d!=0f) {
                            val nx = ddx/d; val ny = ddy/d
                            val dot = mov.vx*nx + mov.vy*ny
                            mov.vx -= 2*dot*nx; mov.vy -= 2*dot*ny
                        }
                        playBallSound(mov)
                        val overlap = (b1.radius+b2.radius) - dist
                        mov.x += nx(overlap, ddx, d)
                        mov.y += ny(overlap, ddy, d)
                    } else {
                        // level≥5: unsnap on collision
                        if (currentLevel >=5 ) {
                            listOf(b1,b2).forEach { bb ->
                                if (bb.placed) {
                                    bb.placed = false
                                    bb.canSnap = false
                                    handler.postDelayed({ bb.canSnap = true }, 500)
                                }
                            }
                        }
                        // swap velocities
                        val tvx=b1.vx; val tvy=b1.vy
                        b1.vx=b2.vx; b1.vy=b2.vy; b2.vx=tvx; b2.vy=tvy
                        playBallSound(b1); playBallSound(b2)
                        val overlap = (b1.radius+b2.radius) - dist
                        val ax = (dx/dist)*overlap/2f
                        val ay = (dy/dist)*overlap/2f
                        b1.x -= ax; b1.y -= ay; b2.x += ax; b2.y += ay
                    }
                }
            }
        }

        // ── 6) Begin vortex when ball qualifies for snapping ─────────────────
        for (i in balls.indices) {
            val ball = balls[i]
            if (!ball.active || ball.placed || ball.orbiting) continue
            if (currentLevel >=5 && !ball.canSnap) continue

            // hole coordinates (absolute or fractional)
            val (fx,fy) = holePositions[i]
            val holeX = if(holePositionsAbsolute) fx else fx*width
            val holeY = if(holePositionsAbsolute) fy else fy*height

            val dx = ball.x - holeX
            val dy = ball.y - holeY
            val dist = hypot(dx.toDouble(), dy.toDouble()).toFloat()
            val speed= hypot(ball.vx.toDouble(), ball.vy.toDouble()).toFloat()

            val threshold = if(i==0) 50*snappingThresholdFactor else ball.radius*snappingThresholdFactor
            if ((dist < threshold && speed<1f) || dist<10f) {
                // start swirling instead of instant snap
                // play initial pwa
                playSound("bell")
                ball.orbiting     = true
                ball.orbitCenterX = holeX
                ball.orbitCenterY = holeY
                ball.orbitRadius  = dist
                ball.orbitAngle   = atan2(dy,dx)
                ball.orbitAccum   = 0f

                        // compute points
                        val pts = ball.basePoints * currentLevel

                        // random angle between -135° and -45° (in radians)
                        val angle = Random.nextDouble(-3 * Math.PI / 3, -Math.PI / 3)

                        // choose a slower speed (e.g. 2px/frame)
                        val speed = 9f

                        val dx = (cos(angle) * speed).toFloat()
                        val dy = (sin(angle) * speed).toFloat()

                        floatingScores += FloatingScore(
                            x      = holeX,
                            y      = holeY,
                            text   = "+$pts",
                            alpha  = 255,
                            size   = 32f * 3,
                            dx     = dx,
                            dy     = dy,
                            color  = floatingColors[i]  // your per‑ring color array
                        )

                        if (currentLevel == 1 && !timerStarted) {
                            timerStarted = true
                            levelStartTime = System.currentTimeMillis()
                        }
                        if (scoreFrozen) {
                            scoreFrozen = false
                            levelStartScore = overallScore
                            levelStartTime = System.currentTimeMillis()
                        }
                    }
                }


        // Ball spawning logic.
        if (currentLevel == 1) {
            if (ballSpawnIndex > 0 && ballSpawnIndex < balls.size && balls[ballSpawnIndex - 1].placed) {
                balls[ballSpawnIndex].active = true
                playBallSound(balls[ballSpawnIndex])
                ballSpawnIndex++
            }
        } else {
            if (ballSpawnIndex < balls.size) {
                if (currentTime - levelStartTime >= ballSpawnIndex * spawnDelay) {
                    if (!balls[ballSpawnIndex].active) {
                        balls[ballSpawnIndex].active = true
                        playBallSound(balls[ballSpawnIndex])
                        ballSpawnIndex++
                    }
                }
            }
        }

        // Level failure handling.
        if (levelTimer <= 0 && !levelCompleted && !levelFailed) {
            levelFailed = true
            gamePaused = true
        }
        if (levelFailed) {
            for (ball in balls) {
                if (ball.active) {
                    val targetX = width - ball.radius
                    val targetY = ball.radius
                    ball.x += (targetX - ball.x) * 1.0f
                    ball.y += (targetY - ball.y) * 1.0f
                    if (hypot((ball.x - targetX).toDouble(), (ball.y - targetY).toDouble()).toFloat() < 5f) {
                        ball.active = false
                    }
                }
            }

            if (balls.none { it.active } && !failureAlertShown) {
                failureAlertShown = true
                playSound("fail")

                // Create a Runnable for showing the "Time's Up!" dialog.
                failureDialogRunnable = Runnable {
                    val dialog = AlertDialog.Builder(context)
                        .setTitle(Html.fromHtml("<font color='#FFFFFF'>Time's up!</font>", Html.FROM_HTML_MODE_LEGACY))
                        .setPositiveButton("Start New Game") { _, _ -> newGame() }
                        .setNegativeButton("Restart last Level $currentLevel at Score: $levelStartScore") { _, _ -> restartLevel() }
                        .setCancelable(false)
                        .create()
                    dialog.window?.apply {
                        setGravity(Gravity.BOTTOM)
                        setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
                        setDimAmount(0f)
                    }
                    dialog.setOnShowListener {
                        dialog.getButton(AlertDialog.BUTTON_POSITIVE)?.apply {
                            setTextColor(Color.GREEN)
                            setShadowLayer(2f, 4f, 4f, Color.BLACK)
                            setTextSize(20f)
                        }
                        dialog.getButton(AlertDialog.BUTTON_NEGATIVE)?.apply {
                            setTextColor(Color.GREEN)
                            setShadowLayer(2f, 4f, 4f, Color.BLACK)
                            setTextSize(20f)
                        }
                    }
                    dialog.show()
                }
                // Post the failure dialog runnable after a delay.
                handler.postDelayed(failureDialogRunnable!!, 1000)
            }
        }

        if (ballSpawnIndex >= balls.size && balls.all { it.placed } && levelTimer > 0 && !levelCompleted) {
            levelCompleted = true
            gamePaused = true

            // Sum each placed ball’s own points (scaled by the current level)

            val placedPoints = balls.sumOf { ball ->
                if (ball.placed) ball.basePoints * currentLevel else 0
            }
            overallScore = levelStartScore + placedPoints

            playSound("success")
            handler.postDelayed({
                val dialog = AlertDialog.Builder(context)
                    .setTitle(Html.fromHtml("<font color='green'>Level $currentLevel completed!<br>Score: $overallScore</font>", Html.FROM_HTML_MODE_LEGACY))
                    .setPositiveButton("Play Next Level") { _, _ -> nextLevel() }
                    .setCancelable(false)
                    .create()
                dialog.window?.apply {
                    setGravity(Gravity.BOTTOM)
                    setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
                    setDimAmount(0f)
                }
                dialog.setOnShowListener {
                    dialog.getButton(AlertDialog.BUTTON_POSITIVE)?.apply {
                        setTextColor(Color.RED)
                        setShadowLayer(2f, 4f, 4f, Color.BLACK)
                        setTextSize(32f)
                    }
                }
                dialog.show()
            }, 1000)
        }
    }

    private fun nx(overlap: Float, dx: Float, distance: Float): Float = (dx / distance) * overlap
    private fun ny(overlap: Float, dy: Float, distance: Float): Float = (dy / distance) * overlap

    private fun playBallSound(ball: Ball) {
        val index = balls.indexOf(ball)
        when (index) {
            0 -> soundPool.play(soundIds["ball1"] ?: 0, 1f, 1f, 0, 0, 1f)
            1 -> soundPool.play(soundIds["ball2"] ?: 0, 1f, 1f, 0, 0, 1f)
            2 -> soundPool.play(soundIds["ball3"] ?: 0, 1f, 1f, 0, 0, 1f)
            3 -> soundPool.play(soundIds["ball4"] ?: 0, 1f, 1f, 0, 0, 1f)
            4 -> soundPool.play(soundIds["ball5"] ?: 0, 1f, 1f, 0, 0, 1f)
        }
    }

    private fun playSound(key: String) {
        soundPool.play(soundIds[key] ?: 0, 1f, 1f, 0, 0, 1f)
    }

    private fun startLevel(resume: Boolean = false) {
        gamePaused = false
        levelFailed = false
        levelCompleted = false

        failureAlertShown = false
        scoreFrozen = true
        timerStarted = (currentLevel != 1)
        if (resume) {
            // on a resume, use your loaded overallScore as the baseline
            levelStartScore = overallScore
            // levelStartTime was already loaded from prefs in loadGameState()
        } else {
            // brand‑new level: snapshot score & reset timer
            levelStartScore = overallScore
            levelStartTime  = System.currentTimeMillis()
        }
        levelTimeLimit = when (currentLevel) {
            in 1..4 -> 60
            5 -> 55
            6 -> 50
            7 -> 45
            8 -> 40
            9 -> 35
            else -> 30
        }
        ballSpawnIndex = 0
        // Initialize ball positions: start from the upper-left.
        for (ball in balls) {
            ball.x = ball.radius
            ball.y = ball.radius
            ball.vx = if (currentLevel <= 2) Random.nextFloat() * 5f - 2.5f else Random.nextFloat() * 10f - 5f
            ball.vy = if (currentLevel <= 2) Random.nextFloat() * 5f - 2.5f else Random.nextFloat() * 10f - 5f
            ball.placed = false
            ball.active = false
        }
        // For level 1, activate the first ball.
        if (currentLevel == 1) {
            balls[0].active = true
            ballSpawnIndex = 1
            playBallSound(balls[0])
        }
        levelStartListener?.onLevelStarted(currentLevel)
    }

    private fun nextLevel() {
        currentLevel++
        startLevel()
    }

    private fun restartLevel() {
        overallScore = levelStartScore
        startLevel()
    }

    private fun newGame() {
        overallScore = 0
        currentLevel = 1
        orientationOffset = 0
        baselineSet = true
        baselineX = 0f
        baselineY = 0f
        resumeGame()
        startLevel()
    }

    private fun saveGameState() {
        prefs.edit()
            .putInt("overallScore", overallScore)
            .putInt("currentLevel", currentLevel)
            .putLong("levelStartTime", levelStartTime)
            .apply()
    }

    private fun loadGameState() {
        val savedScore = prefs.getInt("overallScore", -1)
        val savedLevel = prefs.getInt("currentLevel", -1)
        val savedLevelStartTime = prefs.getLong("levelStartTime", 0L)
        if (savedScore >= 0 && savedLevel >= 0) {
            overallScore = savedScore
            currentLevel = savedLevel
            if (savedLevelStartTime != 0L) {
                levelStartTime = savedLevelStartTime
            }
        }
    }

    private fun showStartDialog() {
        handler.post {
            startDialogShowing = true

            val savedScore = prefs.getInt("overallScore", 0)
            val savedLevel = prefs.getInt("currentLevel", 1)
            val builder = AlertDialog.Builder(context)
                .setTitle(Html.fromHtml("<font color='#FFFFFF'>AimGame</font>", Html.FROM_HTML_MODE_LEGACY))

            if (prefs.contains("overallScore") && prefs.contains("currentLevel")) {
                builder
                    .setMessage(Html.fromHtml("<font color='#FFFFFF'></font>", Html.FROM_HTML_MODE_LEGACY))
                    // 2. Use the local savedScore/savedLevel in the label:
                    .setPositiveButton("Continue last session at Score: $savedScore, Level: $savedLevel") { _, _ ->
                        // 3. Now restore into your fields and start:
                        failureDialogRunnable?.let { handler.removeCallbacks(it) }
                        failureAlertShown = false
                        overallScore = savedScore
                        currentLevel = savedLevel
                        orientationOffset = 0
                        baselineSet = true
                        baselineX = 0f
                        baselineY = 0f
                        startDialogShowing = false
                        startLevel(resume = true)
                    }
                    .setNegativeButton("New Game") { _, _ ->
                        failureDialogRunnable?.let { handler.removeCallbacks(it) }
                        failureAlertShown = false
                        overallScore = 0
                        currentLevel = 1
                        orientationOffset = 0
                        baselineSet = true
                        baselineX = 0f
                        baselineY = 0f
                        startDialogShowing = false
                        startLevel(resume = false)
                    }
            } else {
                builder.setMessage(Html.fromHtml("<font color='#FFFFFF'></font>", Html.FROM_HTML_MODE_LEGACY))
                    .setPositiveButton("Start") { _, _ ->
                        failureDialogRunnable?.let { handler.removeCallbacks(it) }
                        failureAlertShown = false
                        overallScore = 0
                        currentLevel = 1
                        orientationOffset = 0
                        baselineSet = true
                        baselineX = 0f
                        baselineY = 0f
                        startDialogShowing = false
                        startLevel(resume = false)
                    }
            }
            val dialog = builder.setCancelable(false).create()
            dialog.window?.apply {
                setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
                setGravity(Gravity.BOTTOM)
                val screenHeight = context.resources.displayMetrics.heightPixels
                val params = attributes
                params.y = screenHeight / 7
                attributes = params
            }
            dialog.setOnShowListener {
                dialog.getButton(AlertDialog.BUTTON_POSITIVE)?.apply {
                    setTextColor(Color.GREEN)
                    setShadowLayer(2f, 4f, 4f, Color.BLACK)
                }
                dialog.getButton(AlertDialog.BUTTON_NEGATIVE)?.apply {
                    setTextColor(Color.GREEN)
                    setShadowLayer(2f, 4f, 4f, Color.BLACK)
                }
            }
            dialog.show()
        }
    }

    fun pauseGame() {
        if (!timerPaused) {
            // record how many ms have passed so far
            pausedElapsed = System.currentTimeMillis() - levelStartTime
            }
        timerPaused = true
        gamePaused = true
        saveGameState()
        sensorManager.unregisterListener(this)
    }

    private fun resumeGame() {
        if (timerPaused) {
            // restart the clock so that (now – levelStartTime) == pausedElapsed
            levelStartTime = System.currentTimeMillis() - pausedElapsed
            }
        gamePaused = false
        timerPaused = false
        sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_GAME)
    }

    override fun onWindowVisibilityChanged(visibility: Int) {
        super.onWindowVisibilityChanged(visibility)
        if (visibility == VISIBLE) {
            // Clear the failure flags so that updateGameState() does not reschedule the failure dialog.
            levelFailed = false
            failureAlertShown = false
            // Optionally, if you want to restart timing on resume (so that the failure condition does not hold immediately),
            // you might reset levelStartTime here.
            // levelStartTime = System.currentTimeMillis()
            // Now resume sensors, etc.
            if (!startDialogShowing) {
                resumeGame()
                }
        } else {
            // When hidden, cancel any pending dialogs.
            handler.removeCallbacksAndMessages(null)
            pauseGame()
        }
    }

    // (Other functions such as onSensorChanged, level management, save/load dialogs remain as previously.)
    override fun onSensorChanged(event: SensorEvent) {
        if (event.sensor.type == Sensor.TYPE_ACCELEROMETER) {
            val rawX = event.values[0]
            val rawY = event.values[1]

            if (!baselineSet) {
                baselineX = rawX
                baselineY = rawY
                baselineSet = true
                Log.d("SensorCalib", "Calibrated baseline: ($baselineX, $baselineY) for orientationOffset $orientationOffset")
            }

            // Compute effective (calibrated) sensor values.
            val calibratedX = rawX - baselineX
            val calibratedY = rawY - baselineY

            accelX = calibratedX
            accelY = calibratedY
            Log.d("Sensor", "Raw: ($rawX, $rawY); Calibrated: ($calibratedX, $calibratedY); offset: $orientationOffset")
        }
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) { }
}
