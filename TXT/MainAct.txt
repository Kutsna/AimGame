package com.example.aimgame

import android.graphics.Color
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.text.Html
import android.util.Log
import android.util.TypedValue
import android.view.WindowManager
import android.view.animation.AccelerateDecelerateInterpolator
import android.widget.FrameLayout
import android.widget.ImageView
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity(), GameView.LevelStartListener {

    // The red ring’s hole position remains fixed.
    private val redHolePosFraction = Pair(0.5f, 0.483f)

    // Target fractional positions for the rings (used for positioning the views).
    private val violetPos = Pair(0.141f, 0.051f)
    private val goldPos = Pair(0.139f, 0.05f)
    private val greenPos = Pair(0.139f, 0.05f)
    private val yellowPos = Pair(0.139f, 0.05f)
    private val redPos = Pair(0.139f, 0.05f)

    // For computing new hole positions we use the following initial side fractions.
    // (These correspond to the initial unrotated positions of the holes in the ring images.)
    private val violetInitial = Pair(0.573f, 0.52f)
    private val goldInitial   = Pair(0.632f, 0.55f)
    private val greenInitial  = Pair(0.69f, 0.578f)
    private val yellowInitial = Pair(0.75f, 0.607f)
    // The vertex (pivot) for the rotation of the holes is:
    private val vertexFraction = Pair(0.5f, 0.483f)

    // References to the ring ImageViews.
    private lateinit var ivRingViolet: ImageView
    private lateinit var ivRingGold: ImageView
    private lateinit var ivRingGreen: ImageView
    private lateinit var ivRingYellow: ImageView
    private lateinit var ivRingVioletD: ImageView
    private lateinit var ivRingGoldD: ImageView
    private lateinit var ivRingGreenD: ImageView
    private lateinit var ivRingYellowD: ImageView
    private lateinit var ivRingRed: ImageView

    // Reference to GameView.
    private lateinit var gameView: GameView

    private val handler = Handler(Looper.getMainLooper())

    // Global storage for each ring's final rotation.
    private var finalRotationViolet = 0f
    private var finalRotationGold = 0f
    private var finalRotationGreen = 0f
    private var finalRotationYellow = 0f
    private var finalRotationRed = 0f
    // For red ring, we won’t change its rotation.

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // setContentView(R.layout.activity_main)

        // Keep screen on.
        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)

        // Create a FrameLayout to layer views.
        val frameLayout = FrameLayout(this).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.MATCH_PARENT
            )
        }

        // Bottom Layer: Background image.
        val ivBackground = ImageView(this).apply {
            setImageResource(R.drawable.wood_wall)
            scaleType = ImageView.ScaleType.CENTER_CROP
        }
        frameLayout.addView(ivBackground)

        // Middle Layer: Ring overlays.
        ivRingViolet = ImageView(this).apply {
            setImageResource(R.drawable.ring_violet)
            scaleType = ImageView.ScaleType.CENTER
        }
        ivRingVioletD = ImageView(this).apply {
            setImageResource(R.drawable.ring_violet_double)
            scaleType = ImageView.ScaleType.CENTER
        }
        ivRingGold = ImageView(this).apply {
            setImageResource(R.drawable.ring_gold)
            scaleType = ImageView.ScaleType.CENTER
        }
        ivRingGoldD = ImageView(this).apply {
            setImageResource(R.drawable.ring_gold_double)
            scaleType = ImageView.ScaleType.CENTER
        }
        ivRingGreen = ImageView(this).apply {
            setImageResource(R.drawable.ring_green)
            scaleType = ImageView.ScaleType.CENTER
        }
        ivRingGreenD = ImageView(this).apply {
            setImageResource(R.drawable.ring_green_double)
            scaleType = ImageView.ScaleType.CENTER
        }
        ivRingYellow = ImageView(this).apply {
            setImageResource(R.drawable.ring_yellow)
            scaleType = ImageView.ScaleType.CENTER
        }
        ivRingYellowD = ImageView(this).apply {
            setImageResource(R.drawable.ring_yellow_double)
            scaleType = ImageView.ScaleType.CENTER
        }
        ivRingRed = ImageView(this).apply {
            setImageResource(R.drawable.ring_red)
            scaleType = ImageView.ScaleType.CENTER
        }
        frameLayout.addView(ivRingViolet, FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT))
        frameLayout.addView(ivRingGold, FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT))
        frameLayout.addView(ivRingGreen, FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT))
        frameLayout.addView(ivRingYellow, FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT))
        frameLayout.addView(ivRingRed, FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT))

        // Top Layer: GameView.
        gameView = GameView(this)
        gameView.levelStartListener = this
        frameLayout.addView(gameView, FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT))

        setContentView(frameLayout)

        positionRings()
        animateRings()
    }

    // Position rings based on their target fractional positions.
    private fun positionRings() {
        val dm = resources.displayMetrics
        val screenWidth = dm.widthPixels.toFloat()
        val screenHeight = dm.heightPixels.toFloat()
        val ringSizePx = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 100f, dm)
        fun computePosition(fractionX: Float, fractionY: Float): Pair<Float, Float> {
            val x = screenWidth * fractionX - ringSizePx / 2f
            val y = screenHeight * fractionY - ringSizePx / 2f
            return Pair(x, y)
        }
        computePosition(goldPos.first, goldPos.second).apply {
            ivRingGold.x = first
            ivRingGold.y = second
        }
        computePosition(greenPos.first, greenPos.second).apply {
            ivRingGreen.x = first
            ivRingGreen.y = second
        }
        computePosition(redPos.first, redPos.second).apply {
            ivRingRed.x = first
            ivRingRed.y = second
        }
        computePosition(violetPos.first, violetPos.second).apply {
            ivRingViolet.x = first
            ivRingViolet.y = second
        }
        computePosition(yellowPos.first, yellowPos.second).apply {
            ivRingYellow.x = first
            ivRingYellow.y = second
        }
    }

    // Animate rings with a starting rotation of 0.
    private fun animateRings() {
        val dm = resources.displayMetrics
        val screenWidth = dm.widthPixels.toFloat()
        val screenHeight = dm.heightPixels.toFloat()
        val ringSizePx = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 100f, dm)

        // Helper function that now accepts a ring identifier.
        fun animateRing(view: ImageView, finalX: Float, finalY: Float, ringId: String) {
            // Random starting edge.
            val randomEdge = (0..3).random()
            var startX = finalX
            var startY = finalY
            when (randomEdge) {
                0 -> { startX = -ringSizePx; startY = (0..screenHeight.toInt()).random().toFloat() }
                1 -> { startY = -ringSizePx; startX = (0..screenWidth.toInt()).random().toFloat() }
                2 -> { startX = screenWidth + ringSizePx; startY = (0..screenHeight.toInt()).random().toFloat() }
                3 -> { startY = screenHeight + ringSizePx; startX = (0..screenWidth.toInt()).random().toFloat() }
            }
            view.x = startX
            view.y = startY
            // Set starting rotation explicitly to 0.
            view.rotation = 0f
            Log.d("RingAnimation", "Starting rotation for ring $ringId: ${view.rotation}")

            // Choose a random extra rotation.
            val extraRotation = (360..720).random().toFloat()
            view.animate()
                .x(finalX)
                .y(finalY)
                .rotationBy(extraRotation)
                .setDuration(3000)
                .setInterpolator(AccelerateDecelerateInterpolator())
                .withEndAction {
                    val finalRotation = view.rotation
                    Log.d("RingAnimation", "Final rotation for ring $ringId: $finalRotation")
                    // Compute turnDeg = finalRotation; if > 360 subtract 360.
                    var turnDeg = finalRotation
                    if (turnDeg > 360f) {
                        turnDeg -= 360f
                    }
                    Log.d("RingAnimation", "turnDeg for ring $ringId: $turnDeg")
                    // Store the rotation for each ring.
                    when (ringId) {
                        "violet" -> finalRotationYellow = turnDeg
                        "gold" ->  finalRotationGreen = turnDeg
                        "green" ->  finalRotationGold = turnDeg
                        "yellow" ->  finalRotationViolet = turnDeg
                        "red" -> finalRotationRed = turnDeg
                        // For red, we leave it as is.
                    }
                }
                .start()
        }

        // Compute final positions for each ring view.
        fun getFinalPos(fraction: Pair<Float, Float>): Pair<Float, Float> {
            val x = screenWidth * fraction.first - ringSizePx / 2f
            val y = screenHeight * fraction.second - ringSizePx / 2f
            return Pair(x, y)
        }
        val finalGold = getFinalPos(goldPos)
        val finalGreen = getFinalPos(greenPos)
        val finalRed = getFinalPos(redPos)
        val finalViolet = getFinalPos(violetPos)
        val finalYellow = getFinalPos(yellowPos)

        animateRing(ivRingViolet, finalViolet.first, finalViolet.second, "violet")
        animateRing(ivRingGold, finalGold.first, finalGold.second, "gold")
        animateRing(ivRingGreen, finalGreen.first, finalGreen.second, "green")
        animateRing(ivRingYellow, finalYellow.first, finalYellow.second, "yellow")
        animateRing(ivRingRed, finalRed.first, finalRed.second, "red") // red ring is now animated

        // For red ring, no rotation is needed.
        ivRingRed.x = finalRed.first
        ivRingRed.y = finalRed.second
        ivRingRed.rotation = 0f
        Log.d("RingAnimation", "Red ring rotation remains 0.")

        // After animations finish (~3200ms), update hole positions.
        handler.postDelayed({
            updateAndSendHolePositions(ringSizePx)
        }, 3200)
    }

    // Compute the final hole positions using the computed turnDeg for each ring.
    private fun updateAndSendHolePositions(ringSizePx: Float) {
        // Get screen dimensions.
        val dm = resources.displayMetrics
        val screenWidth = dm.widthPixels.toFloat()
        val screenHeight = dm.heightPixels.toFloat()
        // The pivot for rotation in screen coordinates.
        val vertexX = screenWidth * vertexFraction.first
        val vertexY = screenHeight * vertexFraction.second

        // Define a helper to rotate a point around the vertex by an angle (in degrees).
        fun rotatePoint(initial: Pair<Float, Float>, angleDeg: Float): Pair<Float, Float> {
            // Convert initial fraction to screen coordinates.
            val initX = screenWidth * initial.first
            val initY = screenHeight * initial.second
            // Translate to origin.
            val relX = initX - vertexX
            val relY = initY - vertexY
            // Convert angle to radians.
            val rad = Math.toRadians(angleDeg.toDouble())
            val cosA = Math.cos(rad)
            val sinA = Math.sin(rad)
            val rotatedX = (relX * cosA - relY * sinA).toFloat()
            val rotatedY = (relX * sinA + relY * cosA).toFloat()
            // Translate back.
            return Pair(vertexX + rotatedX, vertexY + rotatedY)
        }

        // For each ring, compute its new hole position based on its turnDeg.
        // Note: For each ring, if no rotation was computed (default 0) then new position equals initial.
        val violetNew = rotatePoint(violetInitial, finalRotationViolet)
        val goldNew = rotatePoint(goldInitial, finalRotationGold)
        val greenNew = rotatePoint(greenInitial, finalRotationGreen)
        val yellowNew = rotatePoint(yellowInitial, finalRotationYellow)
        // Red ring hole remains fixed (vertex).
        val redNew = Pair(screenWidth * redHolePosFraction.first, screenHeight * redHolePosFraction.second)

        val newPositions = arrayOf(redNew, violetNew, goldNew, greenNew, yellowNew)
        newPositions.forEachIndexed { index, pos ->
            Log.d("HolePositions", "New hole $index: (${pos.first}, ${pos.second})")
        }
        gameView.updateHolePositions(newPositions, ringFinished = true) // "ringFinished = true" is recently added
        gameView.showHoles = true
        gameView.invalidate()
    }

    // Called when a new level starts.
    override fun onLevelStarted(currentLevel: Int) {
        animateRings()
    }
}
